#!/usr/bin/env node


var fs = require('fs');
var path = require('path');
var readline = require('readline');

var async = require('async');
var fullcontact = require('fullcontact');
var mkdirp = require('mkdirp');
var program = require('commander');
var stormpath = require('stormpath');


// Globals
var VERSION = '0.0.1';
var HOME = process.env[(process.platform == 'win32') ? 'USERPROFILE': 'HOME'];
var CONFIG_DIR = HOME + '/.stormpath/enrich';
var CONFIG_FILE = CONFIG_DIR + '/config.json';
var CONFIG = {
  stormpath_api_key_id: null,
  stormpath_api_key_secret: null,
  fullcontact_api_key : null,
};
var fc;
var spClient;


// Initialize command line.
program
  .version(VERSION)
  .option('-c, --configure', 'Configure enrich.', 'configure')
  .parse(process.argv);


/*
 * Configure enrich by asking for / utilizing a user's Stormpath and FullContact
 * credentials.
 *
 * This will store all configuration information in a JSON file inside
 * ~/.stormpath/enrich/config.json
 */
function configure() {

  var rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  // Ensure the config directory exists.
  mkdirp(CONFIG_DIR, function(err, made) {
    if (err) {
      console.log("ERROR: Can't create configuration directory:", CONFIG_DIR);
      process.exit(1);
    }
  });

  // Grab the user's API keys for Stormpath and FullContact, then store them in
  // the configuration file.
  async.series([
    function(cb) {
      rl.question("Enter your Stormpath API Key ID: ", function(id) {
        CONFIG.stormpath_api_key_id = id.trim();
        cb();
      });
    },
    function(cb) {
      rl.question("Enter your Stormpath API Key Secret: ", function(secret) {
        CONFIG.stormpath_api_key_secret = secret.trim();
        cb();
      });
    },
    function(cb) {
      rl.question("Enter your FullContact API Key: ", function(key) {
        CONFIG.fullcontact_api_key = key.trim();
        cb();
      });
    },
    function(cb) {
      fs.writeFile(CONFIG_FILE, JSON.stringify(CONFIG, null, 2), function(err) {
        if (err) {
          console.log("ERROR: Can't write configuration file:", CONFIG_FILE);
          cb(err);
        }
        cb();
      });
    },
  ], function(err) {
    rl.close();
  });

}


/**
 * Load configuration information from the config file.  If no configuration
 * information can be found, the callback will be called with an error argument.
 *
 * @param {Function} callback The callback function to run after configuration
 *   information has been loaded.  The signature of the callback function is
 *   (err, config), where err is an error, and config is JSON configuration
 *   data.
 **/
function load(callback) {

  var config;

  fs.readFile(CONFIG_FILE, 'utf8', function(err, data) {
    if (err) {
      callback(new Error("ERROR: Couldn't open the configuration file. You need to configure stormpath-enrich to continue!"));
    }

    try {
      config = JSON.parse(data);
    } catch (e) {
      callback(new Error("ERROR: Couldn't parse the configuration data. You need to configure stormpath-enrich to continue!"));
    }

    fc = new fullcontact(config.fullcontact_api_key);

    var apiKey = new stormpath.ApiKey(config.stormpath_api_key_id, config.stormpath_api_key_secret);
    spClient = new stormpath.Client({apiKey: apiKey});

    callback(null, config);
  });

}


/**
 * Grab a person's data using FullContact's API, given an email address.  If no
 * information can be found, the errback will be called.
 *
 * @param {Function} callback The callback function to run after a user's data
 *   has been retrieved.  The signature of the callback function is (err, data)
 *   where data is a JSON object.
 **/
function grabData(email, next) {

  fc.person.email(email, function(err, data) {
    next(err, data);
  });

}


/**
 * Build an array of all Stormpath Directories, then return it.
 *
 * @param {Function} callback The callback function to run after all directories
 *  have been retrieved.  The signature of the callback function is (err, data)
 *  where data is an array of Directory objects.
 **/
function getDirectories(cb) {

  var all_directories = [];

  spClient.getDirectories(function(err, directories) {
    directories.each(function(directory, cb) {
      all_directories.push(directory);
      cb();
    }, function(err) {
      if (err) throw err;
      cb(null, all_directories);
    });
  });

}


/**
 * Update all Stormpath Accounts with FullContact data, given an array of
 * Stormpath Directories.
 *
 * @param {Function} callback The callback function to run after all accounts
 *  have been updated.  The signature of the callback function is (err), where
 *  err is an error.  If err is null, it means all updates completed
 *  successfully.
 **/
function updateAccounts(directories, cb) {

  // Iterate through directories.
  for (var i = 0; i < directories.length; i++) {
    directories[i].getAccounts(function(err, accounts) {

      // Iterate through accounts.
      accounts.each(function(account, c) {

        async.waterfall([
          // Use FullContact to retrieve information about this user.
          function(x) {
            grabData(account.email, x);
          },

          // Use the FullContact data to update this user's account.
          function(data, x) {
            if (data.contactInfo && data.contactInfo.givenName && data.contactInfo.familyName) {
              account.givenName = data.contactInfo.givenName;
              account.surname = data.contactInfo.familyName;
              console.log('givenName:', account.givenName);
              console.log('surname:', account.surname);
              account.save(function(err) {console.log('done');});
            }

            x();
          },
        ]);

        c();
      }, function(err) {
        if (err) {
          cb(err);
        }
        cb();
      });

    });
  }

}


// If we need to configure stuff, let's do it.
if (program.configure) {
  configure();
} else {
  async.waterfall([

    // First, Load configuration details.
    function(done) {
      load(done);
    },

    // Second, iterate through all Stormpath Directories.
    function(done) {
      getDirectories(done);
    },

    // Third, iterate through all Stormpath Accounts.
    function(directories, done) {

      updateAccounts(directories, done);
      //async.eachSeries(directories, function(directory, next_dir) {
      //  directory.getAccounts(function(err, accounts) {
      //    accounts.each(function(account, cb) {
      //      console.log(account);
      //      cb();
      //    }, next_dir);
      //  });
      //}, function(err) {
      //  conso
      //};
    },

  ]);

}
